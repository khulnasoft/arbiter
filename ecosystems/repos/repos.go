// Package repos provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.12.4 DO NOT EDIT.
package repos

import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
)

// Dependency defines model for Dependency.
type Dependency struct {
	Direct       *bool   `json:"direct,omitempty"`
	Ecosystem    *string `json:"ecosystem,omitempty"`
	Id           *int    `json:"id,omitempty"`
	Kind         *string `json:"kind,omitempty"`
	Optional     *bool   `json:"optional,omitempty"`
	PackageName  *string `json:"package_name,omitempty"`
	Requirements *string `json:"requirements,omitempty"`
}

// Ecosystem defines model for Ecosystem.
type Ecosystem struct {
	EcosystemUrl  *string `json:"ecosystem_url,omitempty"`
	Name          *string `json:"name,omitempty"`
	PackagesCount *int    `json:"packages_count,omitempty"`
}

// Host defines model for Host.
type Host struct {
	HostUrl            *string `json:"host_url,omitempty"`
	IconUrl            *string `json:"icon_url,omitempty"`
	Kind               *string `json:"kind,omitempty"`
	Name               *string `json:"name,omitempty"`
	OwnersCount        *int    `json:"owners_count,omitempty"`
	OwnersUrl          *string `json:"owners_url,omitempty"`
	RepositoriesCount  *int    `json:"repositories_count,omitempty"`
	RepositorisUrl     *string `json:"repositoris_url,omitempty"`
	RepositoryNamesUrl *string `json:"repository_names_url,omitempty"`
	Url                *string `json:"url,omitempty"`
}

// Manifest defines model for Manifest.
type Manifest struct {
	CreatedAt      *time.Time    `json:"created_at,omitempty"`
	Dependencies   *[]Dependency `json:"dependencies,omitempty"`
	Ecosystem      *string       `json:"ecosystem,omitempty"`
	Filepath       *string       `json:"filepath,omitempty"`
	Kind           *string       `json:"kind,omitempty"`
	RepositoryLink *string       `json:"repository_link,omitempty"`
	Sha            *string       `json:"sha,omitempty"`
	UpdatedAt      *time.Time    `json:"updated_at,omitempty"`
}

// Owner defines model for Owner.
type Owner struct {
	Company           *string                 `json:"company,omitempty"`
	CreatedAt         *time.Time              `json:"created_at,omitempty"`
	Description       *string                 `json:"description,omitempty"`
	Email             *string                 `json:"email,omitempty"`
	HtmlUrl           *string                 `json:"html_url,omitempty"`
	IconUrl           *string                 `json:"icon_url,omitempty"`
	Kind              *string                 `json:"kind,omitempty"`
	LastSyncedAt      *time.Time              `json:"last_synced_at,omitempty"`
	Location          *string                 `json:"location,omitempty"`
	Login             *string                 `json:"login,omitempty"`
	Metadata          *map[string]interface{} `json:"metadata,omitempty"`
	Name              *string                 `json:"name,omitempty"`
	OwnerUrl          *string                 `json:"owner_url,omitempty"`
	RepositoriesCount *int                    `json:"repositories_count,omitempty"`
	RepositoriesUrl   *string                 `json:"repositories_url,omitempty"`
	Twitter           *string                 `json:"twitter,omitempty"`
	UpdatedAt         *time.Time              `json:"updated_at,omitempty"`
	Uuid              *string                 `json:"uuid,omitempty"`
	Website           *string                 `json:"website,omitempty"`
}

// PackageUsage defines model for PackageUsage.
type PackageUsage struct {
	DependenciesUrl *string                 `json:"dependencies_url,omitempty"`
	DependentsCount *int                    `json:"dependents_count,omitempty"`
	Direct          *map[string]interface{} `json:"direct,omitempty"`
	Ecosystem       *string                 `json:"ecosystem,omitempty"`
	Kind            *map[string]interface{} `json:"kind,omitempty"`
	Name            *string                 `json:"name,omitempty"`
	PackageUsageUrl *string                 `json:"package_usage_url,omitempty"`
	Requirements    *map[string]interface{} `json:"requirements,omitempty"`
}

// Repository defines model for Repository.
type Repository struct {
	Archived             *bool                   `json:"archived,omitempty"`
	CommitStats          *map[string]interface{} `json:"commit_stats,omitempty"`
	CreatedAt            *time.Time              `json:"created_at,omitempty"`
	DefaultBranch        *string                 `json:"default_branch,omitempty"`
	DependenciesParsedAt *time.Time              `json:"dependencies_parsed_at,omitempty"`
	DependencyJobId      *string                 `json:"dependency_job_id,omitempty"`
	Description          *string                 `json:"description,omitempty"`
	Etag                 *string                 `json:"etag,omitempty"`
	Fork                 *bool                   `json:"fork,omitempty"`
	ForksCount           *int                    `json:"forks_count,omitempty"`
	FullName             *string                 `json:"full_name,omitempty"`
	HasIssues            *bool                   `json:"has_issues,omitempty"`
	HasPages             *bool                   `json:"has_pages,omitempty"`
	HasWiki              *bool                   `json:"has_wiki,omitempty"`
	Homepage             *string                 `json:"homepage,omitempty"`
	Host                 *Host                   `json:"host,omitempty"`
	HtmlUrl              *string                 `json:"html_url,omitempty"`
	IconUrl              *string                 `json:"icon_url,omitempty"`
	Language             *string                 `json:"language,omitempty"`
	LastSyncedAt         *time.Time              `json:"last_synced_at,omitempty"`
	LatestCommitSha      *string                 `json:"latest_commit_sha,omitempty"`
	License              *string                 `json:"license,omitempty"`
	ManifestsUrl         *string                 `json:"manifests_url,omitempty"`
	Metadata             *map[string]interface{} `json:"metadata,omitempty"`
	MirrorUrl            *string                 `json:"mirror_url,omitempty"`
	OpenIssuesCount      *int                    `json:"open_issues_count,omitempty"`
	Owner                *string                 `json:"owner,omitempty"`
	OwnerUrl             *string                 `json:"owner_url,omitempty"`
	PullRequestsEnabled  *bool                   `json:"pull_requests_enabled,omitempty"`
	PushedAt             *time.Time              `json:"pushed_at,omitempty"`
	RepositoryUrl        *string                 `json:"repository_url,omitempty"`
	Scm                  *string                 `json:"scm,omitempty"`
	Size                 *int                    `json:"size,omitempty"`
	SourceName           *string                 `json:"source_name,omitempty"`
	StargazersCount      *int                    `json:"stargazers_count,omitempty"`
	Status               *string                 `json:"status,omitempty"`
	SubscribersCount     *int                    `json:"subscribers_count,omitempty"`
	TagsUrl              *string                 `json:"tags_url,omitempty"`
	Topics               *[]string               `json:"topics,omitempty"`
	UpdatedAt            *time.Time              `json:"updated_at,omitempty"`
	Uuid                 *string                 `json:"uuid,omitempty"`
}

// Tag defines model for Tag.
type Tag struct {
	DownloadUrl *string    `json:"download_url,omitempty"`
	HtmlUrl     *string    `json:"html_url,omitempty"`
	Kind        *string    `json:"kind,omitempty"`
	Name        *string    `json:"name,omitempty"`
	PublishedAt *time.Time `json:"published_at,omitempty"`
	Sha         *string    `json:"sha,omitempty"`
}

// Topic defines model for Topic.
type Topic struct {
	Name              *string `json:"name,omitempty"`
	RepositoriesCount *int    `json:"repositories_count,omitempty"`
	TopicUrl          *string `json:"topic_url,omitempty"`
}

// TopicWithRepositories defines model for TopicWithRepositories.
type TopicWithRepositories struct {
	Name              *string       `json:"name,omitempty"`
	RelatedTopics     *[]Topic      `json:"related_topics,omitempty"`
	Repositories      *[]Repository `json:"repositories,omitempty"`
	RepositoriesCount *int          `json:"repositories_count,omitempty"`
	TopicUrl          *string       `json:"topic_url,omitempty"`
}

// GetRegistriesParams defines parameters for GetRegistries.
type GetRegistriesParams struct {
	// Page pagination page number
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// PerPage Number of records to return
	PerPage *int `form:"per_page,omitempty" json:"per_page,omitempty"`
}

// GetHostParams defines parameters for GetHost.
type GetHostParams struct {
	// Page pagination page number
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// PerPage Number of records to return
	PerPage *int `form:"per_page,omitempty" json:"per_page,omitempty"`
}

// GetHostOwnersParams defines parameters for GetHostOwners.
type GetHostOwnersParams struct {
	// Page pagination page number
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// PerPage Number of records to return
	PerPage *int `form:"per_page,omitempty" json:"per_page,omitempty"`

	// CreatedAfter filter by created_at after given time
	CreatedAfter *time.Time `form:"created_after,omitempty" json:"created_after,omitempty"`

	// UpdatedAfter filter by updated_at after given time
	UpdatedAfter *time.Time `form:"updated_after,omitempty" json:"updated_after,omitempty"`

	// Sort field to order results by
	Sort *string `form:"sort,omitempty" json:"sort,omitempty"`

	// Order direction to order results by
	Order *string `form:"order,omitempty" json:"order,omitempty"`
}

// GetHostOwnerRepositoriesParams defines parameters for GetHostOwnerRepositories.
type GetHostOwnerRepositoriesParams struct {
	// Page pagination page number
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// PerPage Number of records to return
	PerPage *int `form:"per_page,omitempty" json:"per_page,omitempty"`

	// CreatedAfter filter by created_at after given time
	CreatedAfter *time.Time `form:"created_after,omitempty" json:"created_after,omitempty"`

	// UpdatedAfter filter by updated_at after given time
	UpdatedAfter *time.Time `form:"updated_after,omitempty" json:"updated_after,omitempty"`

	// Sort field to order results by
	Sort *string `form:"sort,omitempty" json:"sort,omitempty"`

	// Order direction to order results by
	Order *string `form:"order,omitempty" json:"order,omitempty"`
}

// GetHostRepositoriesParams defines parameters for GetHostRepositories.
type GetHostRepositoriesParams struct {
	// Page pagination page number
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// PerPage Number of records to return
	PerPage *int `form:"per_page,omitempty" json:"per_page,omitempty"`

	// CreatedAfter filter by created_at after given time
	CreatedAfter *time.Time `form:"created_after,omitempty" json:"created_after,omitempty"`

	// UpdatedAfter filter by updated_at after given time
	UpdatedAfter *time.Time `form:"updated_after,omitempty" json:"updated_after,omitempty"`

	// Sort field to order results by
	Sort *string `form:"sort,omitempty" json:"sort,omitempty"`

	// Order direction to order results by
	Order *string `form:"order,omitempty" json:"order,omitempty"`
}

// GetHostRepositoryManifestsParams defines parameters for GetHostRepositoryManifests.
type GetHostRepositoryManifestsParams struct {
	// Page pagination page number
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// PerPage Number of records to return
	PerPage *int `form:"per_page,omitempty" json:"per_page,omitempty"`
}

// GetHostRepositoryTagsParams defines parameters for GetHostRepositoryTags.
type GetHostRepositoryTagsParams struct {
	// Page pagination page number
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// PerPage Number of records to return
	PerPage *int `form:"per_page,omitempty" json:"per_page,omitempty"`
}

// GetHostRepositoryNamesParams defines parameters for GetHostRepositoryNames.
type GetHostRepositoryNamesParams struct {
	// Page pagination page number
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// PerPage Number of records to return
	PerPage *int `form:"per_page,omitempty" json:"per_page,omitempty"`

	// CreatedAfter filter by created_at after given time
	CreatedAfter *time.Time `form:"created_after,omitempty" json:"created_after,omitempty"`

	// UpdatedAfter filter by updated_at after given time
	UpdatedAfter *time.Time `form:"updated_after,omitempty" json:"updated_after,omitempty"`

	// Sort field to order results by
	Sort *string `form:"sort,omitempty" json:"sort,omitempty"`

	// Order direction to order results by
	Order *string `form:"order,omitempty" json:"order,omitempty"`
}

// RepositoriesLookupParams defines parameters for RepositoriesLookup.
type RepositoriesLookupParams struct {
	// Url The URL of the repository to lookup
	Url string `form:"url" json:"url"`
}

// TopicsParams defines parameters for Topics.
type TopicsParams struct {
	// Page pagination page number
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// PerPage Number of records to return
	PerPage *int `form:"per_page,omitempty" json:"per_page,omitempty"`
}

// TopicParams defines parameters for Topic.
type TopicParams struct {
	// Page pagination page number
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// PerPage Number of records to return
	PerPage *int `form:"per_page,omitempty" json:"per_page,omitempty"`
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetRegistries request
	GetRegistries(ctx context.Context, params *GetRegistriesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetHost request
	GetHost(ctx context.Context, hostName string, params *GetHostParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetHostOwners request
	GetHostOwners(ctx context.Context, hostName string, params *GetHostOwnersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetHostOwner request
	GetHostOwner(ctx context.Context, hostName string, ownerLogin string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetHostOwnerRepositories request
	GetHostOwnerRepositories(ctx context.Context, hostName string, ownerLogin string, params *GetHostOwnerRepositoriesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetHostRepositories request
	GetHostRepositories(ctx context.Context, hostName string, params *GetHostRepositoriesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetHostRepository request
	GetHostRepository(ctx context.Context, hostName string, repositoryName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetHostRepositoryManifests request
	GetHostRepositoryManifests(ctx context.Context, hostName string, repositoryName string, params *GetHostRepositoryManifestsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetHostRepositoryTags request
	GetHostRepositoryTags(ctx context.Context, hostName string, repositoryName string, params *GetHostRepositoryTagsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetHostRepositoryNames request
	GetHostRepositoryNames(ctx context.Context, hostName string, params *GetHostRepositoryNamesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RepositoriesLookup request
	RepositoriesLookup(ctx context.Context, params *RepositoriesLookupParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Topics request
	Topics(ctx context.Context, params *TopicsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Topic request
	Topic(ctx context.Context, topic string, params *TopicParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Usage request
	Usage(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UsageEcosystem request
	UsageEcosystem(ctx context.Context, ecosystem string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UsagePackage request
	UsagePackage(ctx context.Context, ecosystem string, pPackage string, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) GetRegistries(ctx context.Context, params *GetRegistriesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRegistriesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetHost(ctx context.Context, hostName string, params *GetHostParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetHostRequest(c.Server, hostName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetHostOwners(ctx context.Context, hostName string, params *GetHostOwnersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetHostOwnersRequest(c.Server, hostName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetHostOwner(ctx context.Context, hostName string, ownerLogin string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetHostOwnerRequest(c.Server, hostName, ownerLogin)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetHostOwnerRepositories(ctx context.Context, hostName string, ownerLogin string, params *GetHostOwnerRepositoriesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetHostOwnerRepositoriesRequest(c.Server, hostName, ownerLogin, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetHostRepositories(ctx context.Context, hostName string, params *GetHostRepositoriesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetHostRepositoriesRequest(c.Server, hostName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetHostRepository(ctx context.Context, hostName string, repositoryName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetHostRepositoryRequest(c.Server, hostName, repositoryName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetHostRepositoryManifests(ctx context.Context, hostName string, repositoryName string, params *GetHostRepositoryManifestsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetHostRepositoryManifestsRequest(c.Server, hostName, repositoryName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetHostRepositoryTags(ctx context.Context, hostName string, repositoryName string, params *GetHostRepositoryTagsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetHostRepositoryTagsRequest(c.Server, hostName, repositoryName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetHostRepositoryNames(ctx context.Context, hostName string, params *GetHostRepositoryNamesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetHostRepositoryNamesRequest(c.Server, hostName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RepositoriesLookup(ctx context.Context, params *RepositoriesLookupParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRepositoriesLookupRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Topics(ctx context.Context, params *TopicsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTopicsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Topic(ctx context.Context, topic string, params *TopicParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTopicRequest(c.Server, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Usage(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUsageRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UsageEcosystem(ctx context.Context, ecosystem string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUsageEcosystemRequest(c.Server, ecosystem)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UsagePackage(ctx context.Context, ecosystem string, pPackage string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUsagePackageRequest(c.Server, ecosystem, pPackage)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewGetRegistriesRequest generates requests for GetRegistries
func NewGetRegistriesRequest(server string, params *GetRegistriesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/hosts")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetHostRequest generates requests for GetHost
func NewGetHostRequest(server string, hostName string, params *GetHostParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "hostName", runtime.ParamLocationPath, hostName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/hosts/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetHostOwnersRequest generates requests for GetHostOwners
func NewGetHostOwnersRequest(server string, hostName string, params *GetHostOwnersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "hostName", runtime.ParamLocationPath, hostName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/hosts/%s/owners", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.CreatedAfter != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "created_after", runtime.ParamLocationQuery, *params.CreatedAfter); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.UpdatedAfter != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "updated_after", runtime.ParamLocationQuery, *params.UpdatedAfter); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Sort != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Order != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetHostOwnerRequest generates requests for GetHostOwner
func NewGetHostOwnerRequest(server string, hostName string, ownerLogin string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "hostName", runtime.ParamLocationPath, hostName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "ownerLogin", runtime.ParamLocationPath, ownerLogin)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/hosts/%s/owners/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetHostOwnerRepositoriesRequest generates requests for GetHostOwnerRepositories
func NewGetHostOwnerRepositoriesRequest(server string, hostName string, ownerLogin string, params *GetHostOwnerRepositoriesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "hostName", runtime.ParamLocationPath, hostName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "ownerLogin", runtime.ParamLocationPath, ownerLogin)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/hosts/%s/owners/%s/repositories", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.CreatedAfter != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "created_after", runtime.ParamLocationQuery, *params.CreatedAfter); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.UpdatedAfter != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "updated_after", runtime.ParamLocationQuery, *params.UpdatedAfter); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Sort != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Order != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetHostRepositoriesRequest generates requests for GetHostRepositories
func NewGetHostRepositoriesRequest(server string, hostName string, params *GetHostRepositoriesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "hostName", runtime.ParamLocationPath, hostName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/hosts/%s/repositories", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.CreatedAfter != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "created_after", runtime.ParamLocationQuery, *params.CreatedAfter); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.UpdatedAfter != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "updated_after", runtime.ParamLocationQuery, *params.UpdatedAfter); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Sort != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Order != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetHostRepositoryRequest generates requests for GetHostRepository
func NewGetHostRepositoryRequest(server string, hostName string, repositoryName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "hostName", runtime.ParamLocationPath, hostName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositoryName", runtime.ParamLocationPath, repositoryName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/hosts/%s/repositories/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetHostRepositoryManifestsRequest generates requests for GetHostRepositoryManifests
func NewGetHostRepositoryManifestsRequest(server string, hostName string, repositoryName string, params *GetHostRepositoryManifestsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "hostName", runtime.ParamLocationPath, hostName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositoryName", runtime.ParamLocationPath, repositoryName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/hosts/%s/repositories/%s/manifests", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetHostRepositoryTagsRequest generates requests for GetHostRepositoryTags
func NewGetHostRepositoryTagsRequest(server string, hostName string, repositoryName string, params *GetHostRepositoryTagsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "hostName", runtime.ParamLocationPath, hostName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repositoryName", runtime.ParamLocationPath, repositoryName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/hosts/%s/repositories/%s/tags", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetHostRepositoryNamesRequest generates requests for GetHostRepositoryNames
func NewGetHostRepositoryNamesRequest(server string, hostName string, params *GetHostRepositoryNamesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "hostName", runtime.ParamLocationPath, hostName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/hosts/%s/repository_names", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.CreatedAfter != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "created_after", runtime.ParamLocationQuery, *params.CreatedAfter); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.UpdatedAfter != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "updated_after", runtime.ParamLocationQuery, *params.UpdatedAfter); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Sort != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Order != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRepositoriesLookupRequest generates requests for RepositoriesLookup
func NewRepositoriesLookupRequest(server string, params *RepositoriesLookupParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/lookup")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "url", runtime.ParamLocationQuery, params.Url); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTopicsRequest generates requests for Topics
func NewTopicsRequest(server string, params *TopicsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/topics")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTopicRequest generates requests for Topic
func NewTopicRequest(server string, topic string, params *TopicParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/topics/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUsageRequest generates requests for Usage
func NewUsageRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/usage")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUsageEcosystemRequest generates requests for UsageEcosystem
func NewUsageEcosystemRequest(server string, ecosystem string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ecosystem", runtime.ParamLocationPath, ecosystem)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/usage/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUsagePackageRequest generates requests for UsagePackage
func NewUsagePackageRequest(server string, ecosystem string, pPackage string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ecosystem", runtime.ParamLocationPath, ecosystem)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "package", runtime.ParamLocationPath, pPackage)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/usage/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetRegistries request
	GetRegistriesWithResponse(ctx context.Context, params *GetRegistriesParams, reqEditors ...RequestEditorFn) (*GetRegistriesResponse, error)

	// GetHost request
	GetHostWithResponse(ctx context.Context, hostName string, params *GetHostParams, reqEditors ...RequestEditorFn) (*GetHostResponse, error)

	// GetHostOwners request
	GetHostOwnersWithResponse(ctx context.Context, hostName string, params *GetHostOwnersParams, reqEditors ...RequestEditorFn) (*GetHostOwnersResponse, error)

	// GetHostOwner request
	GetHostOwnerWithResponse(ctx context.Context, hostName string, ownerLogin string, reqEditors ...RequestEditorFn) (*GetHostOwnerResponse, error)

	// GetHostOwnerRepositories request
	GetHostOwnerRepositoriesWithResponse(ctx context.Context, hostName string, ownerLogin string, params *GetHostOwnerRepositoriesParams, reqEditors ...RequestEditorFn) (*GetHostOwnerRepositoriesResponse, error)

	// GetHostRepositories request
	GetHostRepositoriesWithResponse(ctx context.Context, hostName string, params *GetHostRepositoriesParams, reqEditors ...RequestEditorFn) (*GetHostRepositoriesResponse, error)

	// GetHostRepository request
	GetHostRepositoryWithResponse(ctx context.Context, hostName string, repositoryName string, reqEditors ...RequestEditorFn) (*GetHostRepositoryResponse, error)

	// GetHostRepositoryManifests request
	GetHostRepositoryManifestsWithResponse(ctx context.Context, hostName string, repositoryName string, params *GetHostRepositoryManifestsParams, reqEditors ...RequestEditorFn) (*GetHostRepositoryManifestsResponse, error)

	// GetHostRepositoryTags request
	GetHostRepositoryTagsWithResponse(ctx context.Context, hostName string, repositoryName string, params *GetHostRepositoryTagsParams, reqEditors ...RequestEditorFn) (*GetHostRepositoryTagsResponse, error)

	// GetHostRepositoryNames request
	GetHostRepositoryNamesWithResponse(ctx context.Context, hostName string, params *GetHostRepositoryNamesParams, reqEditors ...RequestEditorFn) (*GetHostRepositoryNamesResponse, error)

	// RepositoriesLookup request
	RepositoriesLookupWithResponse(ctx context.Context, params *RepositoriesLookupParams, reqEditors ...RequestEditorFn) (*RepositoriesLookupResponse, error)

	// Topics request
	TopicsWithResponse(ctx context.Context, params *TopicsParams, reqEditors ...RequestEditorFn) (*TopicsResponse, error)

	// Topic request
	TopicWithResponse(ctx context.Context, topic string, params *TopicParams, reqEditors ...RequestEditorFn) (*TopicResponse, error)

	// Usage request
	UsageWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*UsageResponse, error)

	// UsageEcosystem request
	UsageEcosystemWithResponse(ctx context.Context, ecosystem string, reqEditors ...RequestEditorFn) (*UsageEcosystemResponse, error)

	// UsagePackage request
	UsagePackageWithResponse(ctx context.Context, ecosystem string, pPackage string, reqEditors ...RequestEditorFn) (*UsagePackageResponse, error)
}

type GetRegistriesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Host
}

// Status returns HTTPResponse.Status
func (r GetRegistriesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRegistriesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetHostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Host
}

// Status returns HTTPResponse.Status
func (r GetHostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetHostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetHostOwnersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Owner
}

// Status returns HTTPResponse.Status
func (r GetHostOwnersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetHostOwnersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetHostOwnerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Owner
}

// Status returns HTTPResponse.Status
func (r GetHostOwnerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetHostOwnerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetHostOwnerRepositoriesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Repository
}

// Status returns HTTPResponse.Status
func (r GetHostOwnerRepositoriesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetHostOwnerRepositoriesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetHostRepositoriesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Repository
}

// Status returns HTTPResponse.Status
func (r GetHostRepositoriesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetHostRepositoriesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetHostRepositoryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Repository
}

// Status returns HTTPResponse.Status
func (r GetHostRepositoryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetHostRepositoryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetHostRepositoryManifestsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Manifest
}

// Status returns HTTPResponse.Status
func (r GetHostRepositoryManifestsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetHostRepositoryManifestsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetHostRepositoryTagsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Tag
}

// Status returns HTTPResponse.Status
func (r GetHostRepositoryTagsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetHostRepositoryTagsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetHostRepositoryNamesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]string
}

// Status returns HTTPResponse.Status
func (r GetHostRepositoryNamesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetHostRepositoryNamesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RepositoriesLookupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Repository
}

// Status returns HTTPResponse.Status
func (r RepositoriesLookupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RepositoriesLookupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TopicsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Topic
}

// Status returns HTTPResponse.Status
func (r TopicsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TopicsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TopicResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TopicWithRepositories
}

// Status returns HTTPResponse.Status
func (r TopicResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TopicResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UsageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Ecosystem
}

// Status returns HTTPResponse.Status
func (r UsageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UsageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UsageEcosystemResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]PackageUsage
}

// Status returns HTTPResponse.Status
func (r UsageEcosystemResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UsageEcosystemResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UsagePackageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PackageUsage
}

// Status returns HTTPResponse.Status
func (r UsagePackageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UsagePackageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetRegistriesWithResponse request returning *GetRegistriesResponse
func (c *ClientWithResponses) GetRegistriesWithResponse(ctx context.Context, params *GetRegistriesParams, reqEditors ...RequestEditorFn) (*GetRegistriesResponse, error) {
	rsp, err := c.GetRegistries(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRegistriesResponse(rsp)
}

// GetHostWithResponse request returning *GetHostResponse
func (c *ClientWithResponses) GetHostWithResponse(ctx context.Context, hostName string, params *GetHostParams, reqEditors ...RequestEditorFn) (*GetHostResponse, error) {
	rsp, err := c.GetHost(ctx, hostName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetHostResponse(rsp)
}

// GetHostOwnersWithResponse request returning *GetHostOwnersResponse
func (c *ClientWithResponses) GetHostOwnersWithResponse(ctx context.Context, hostName string, params *GetHostOwnersParams, reqEditors ...RequestEditorFn) (*GetHostOwnersResponse, error) {
	rsp, err := c.GetHostOwners(ctx, hostName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetHostOwnersResponse(rsp)
}

// GetHostOwnerWithResponse request returning *GetHostOwnerResponse
func (c *ClientWithResponses) GetHostOwnerWithResponse(ctx context.Context, hostName string, ownerLogin string, reqEditors ...RequestEditorFn) (*GetHostOwnerResponse, error) {
	rsp, err := c.GetHostOwner(ctx, hostName, ownerLogin, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetHostOwnerResponse(rsp)
}

// GetHostOwnerRepositoriesWithResponse request returning *GetHostOwnerRepositoriesResponse
func (c *ClientWithResponses) GetHostOwnerRepositoriesWithResponse(ctx context.Context, hostName string, ownerLogin string, params *GetHostOwnerRepositoriesParams, reqEditors ...RequestEditorFn) (*GetHostOwnerRepositoriesResponse, error) {
	rsp, err := c.GetHostOwnerRepositories(ctx, hostName, ownerLogin, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetHostOwnerRepositoriesResponse(rsp)
}

// GetHostRepositoriesWithResponse request returning *GetHostRepositoriesResponse
func (c *ClientWithResponses) GetHostRepositoriesWithResponse(ctx context.Context, hostName string, params *GetHostRepositoriesParams, reqEditors ...RequestEditorFn) (*GetHostRepositoriesResponse, error) {
	rsp, err := c.GetHostRepositories(ctx, hostName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetHostRepositoriesResponse(rsp)
}

// GetHostRepositoryWithResponse request returning *GetHostRepositoryResponse
func (c *ClientWithResponses) GetHostRepositoryWithResponse(ctx context.Context, hostName string, repositoryName string, reqEditors ...RequestEditorFn) (*GetHostRepositoryResponse, error) {
	rsp, err := c.GetHostRepository(ctx, hostName, repositoryName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetHostRepositoryResponse(rsp)
}

// GetHostRepositoryManifestsWithResponse request returning *GetHostRepositoryManifestsResponse
func (c *ClientWithResponses) GetHostRepositoryManifestsWithResponse(ctx context.Context, hostName string, repositoryName string, params *GetHostRepositoryManifestsParams, reqEditors ...RequestEditorFn) (*GetHostRepositoryManifestsResponse, error) {
	rsp, err := c.GetHostRepositoryManifests(ctx, hostName, repositoryName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetHostRepositoryManifestsResponse(rsp)
}

// GetHostRepositoryTagsWithResponse request returning *GetHostRepositoryTagsResponse
func (c *ClientWithResponses) GetHostRepositoryTagsWithResponse(ctx context.Context, hostName string, repositoryName string, params *GetHostRepositoryTagsParams, reqEditors ...RequestEditorFn) (*GetHostRepositoryTagsResponse, error) {
	rsp, err := c.GetHostRepositoryTags(ctx, hostName, repositoryName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetHostRepositoryTagsResponse(rsp)
}

// GetHostRepositoryNamesWithResponse request returning *GetHostRepositoryNamesResponse
func (c *ClientWithResponses) GetHostRepositoryNamesWithResponse(ctx context.Context, hostName string, params *GetHostRepositoryNamesParams, reqEditors ...RequestEditorFn) (*GetHostRepositoryNamesResponse, error) {
	rsp, err := c.GetHostRepositoryNames(ctx, hostName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetHostRepositoryNamesResponse(rsp)
}

// RepositoriesLookupWithResponse request returning *RepositoriesLookupResponse
func (c *ClientWithResponses) RepositoriesLookupWithResponse(ctx context.Context, params *RepositoriesLookupParams, reqEditors ...RequestEditorFn) (*RepositoriesLookupResponse, error) {
	rsp, err := c.RepositoriesLookup(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRepositoriesLookupResponse(rsp)
}

// TopicsWithResponse request returning *TopicsResponse
func (c *ClientWithResponses) TopicsWithResponse(ctx context.Context, params *TopicsParams, reqEditors ...RequestEditorFn) (*TopicsResponse, error) {
	rsp, err := c.Topics(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTopicsResponse(rsp)
}

// TopicWithResponse request returning *TopicResponse
func (c *ClientWithResponses) TopicWithResponse(ctx context.Context, topic string, params *TopicParams, reqEditors ...RequestEditorFn) (*TopicResponse, error) {
	rsp, err := c.Topic(ctx, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTopicResponse(rsp)
}

// UsageWithResponse request returning *UsageResponse
func (c *ClientWithResponses) UsageWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*UsageResponse, error) {
	rsp, err := c.Usage(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUsageResponse(rsp)
}

// UsageEcosystemWithResponse request returning *UsageEcosystemResponse
func (c *ClientWithResponses) UsageEcosystemWithResponse(ctx context.Context, ecosystem string, reqEditors ...RequestEditorFn) (*UsageEcosystemResponse, error) {
	rsp, err := c.UsageEcosystem(ctx, ecosystem, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUsageEcosystemResponse(rsp)
}

// UsagePackageWithResponse request returning *UsagePackageResponse
func (c *ClientWithResponses) UsagePackageWithResponse(ctx context.Context, ecosystem string, pPackage string, reqEditors ...RequestEditorFn) (*UsagePackageResponse, error) {
	rsp, err := c.UsagePackage(ctx, ecosystem, pPackage, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUsagePackageResponse(rsp)
}

// ParseGetRegistriesResponse parses an HTTP response from a GetRegistriesWithResponse call
func ParseGetRegistriesResponse(rsp *http.Response) (*GetRegistriesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRegistriesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Host
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetHostResponse parses an HTTP response from a GetHostWithResponse call
func ParseGetHostResponse(rsp *http.Response) (*GetHostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetHostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Host
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetHostOwnersResponse parses an HTTP response from a GetHostOwnersWithResponse call
func ParseGetHostOwnersResponse(rsp *http.Response) (*GetHostOwnersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetHostOwnersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Owner
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetHostOwnerResponse parses an HTTP response from a GetHostOwnerWithResponse call
func ParseGetHostOwnerResponse(rsp *http.Response) (*GetHostOwnerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetHostOwnerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Owner
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetHostOwnerRepositoriesResponse parses an HTTP response from a GetHostOwnerRepositoriesWithResponse call
func ParseGetHostOwnerRepositoriesResponse(rsp *http.Response) (*GetHostOwnerRepositoriesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetHostOwnerRepositoriesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Repository
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetHostRepositoriesResponse parses an HTTP response from a GetHostRepositoriesWithResponse call
func ParseGetHostRepositoriesResponse(rsp *http.Response) (*GetHostRepositoriesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetHostRepositoriesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Repository
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetHostRepositoryResponse parses an HTTP response from a GetHostRepositoryWithResponse call
func ParseGetHostRepositoryResponse(rsp *http.Response) (*GetHostRepositoryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetHostRepositoryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Repository
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetHostRepositoryManifestsResponse parses an HTTP response from a GetHostRepositoryManifestsWithResponse call
func ParseGetHostRepositoryManifestsResponse(rsp *http.Response) (*GetHostRepositoryManifestsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetHostRepositoryManifestsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Manifest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetHostRepositoryTagsResponse parses an HTTP response from a GetHostRepositoryTagsWithResponse call
func ParseGetHostRepositoryTagsResponse(rsp *http.Response) (*GetHostRepositoryTagsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetHostRepositoryTagsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Tag
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetHostRepositoryNamesResponse parses an HTTP response from a GetHostRepositoryNamesWithResponse call
func ParseGetHostRepositoryNamesResponse(rsp *http.Response) (*GetHostRepositoryNamesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetHostRepositoryNamesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseRepositoriesLookupResponse parses an HTTP response from a RepositoriesLookupWithResponse call
func ParseRepositoriesLookupResponse(rsp *http.Response) (*RepositoriesLookupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RepositoriesLookupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Repository
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseTopicsResponse parses an HTTP response from a TopicsWithResponse call
func ParseTopicsResponse(rsp *http.Response) (*TopicsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TopicsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Topic
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseTopicResponse parses an HTTP response from a TopicWithResponse call
func ParseTopicResponse(rsp *http.Response) (*TopicResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TopicResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TopicWithRepositories
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUsageResponse parses an HTTP response from a UsageWithResponse call
func ParseUsageResponse(rsp *http.Response) (*UsageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UsageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Ecosystem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUsageEcosystemResponse parses an HTTP response from a UsageEcosystemWithResponse call
func ParseUsageEcosystemResponse(rsp *http.Response) (*UsageEcosystemResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UsageEcosystemResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []PackageUsage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUsagePackageResponse parses an HTTP response from a UsagePackageWithResponse call
func ParseUsagePackageResponse(rsp *http.Response) (*UsagePackageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UsagePackageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PackageUsage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}
